0) Сигнатура функции функции включает в себя название функции и упорядоченный набор аргументов с типом данных. 
	Одинаковые функции: 
		int func (int *x, int *y); 
		float func (int *x, int *y);
	Разные функции:
		void func (float *x, float *y);
		void func (int *x, int *y);

1) Полиморфизм функции позволяет одной функции работать с разными типами данных/

2) Перегрузка функции позволяет использовать несколько различных функций с одним и тем же именем. Это тем самым "перегружает" общее имя данных функций. 
	Пример перегрузки функции:
		float sum (float *x, float *y)
		{
			return(x + y);
		}
		int sum (int *x, int *y)
		{
			return(x + y);
		}

	
3) Аргумент по умолчанию представляет собой значение, которое используется автоматически если соответсвующий аргумент не был указан.

4) Шабло́ны — средство языка C++, предназначенное для кодирования обобщённых алгоритмов, без привязки к некоторым параметрам (например, типам данных, значениям по умолчанию). Тем самым шаблоны позволяют повторно использовать одни и те же функции для обработки данных разных типов. Главное преимущество шаблонов том, что они не перегружают имя фунций. Так произодит потому что компилятор сам генирирует функцию с нужным типом данных. Однако шаблоны функций нельзя использовать для всех типов данных поскольку не для каких то типов данных функция может не выполняться.

5) Явная специализация - это определение шаблонов для кокретных типов данных. Это позволяет работать одному и тому же шаблону работать по-разному для разных типов данных. Поэтому такие шаблоны, в отличии от обычных, могут работать лишь для определенных типов аргументов.
Рассмотрим это на примере функции sum:
	- обычный шаблон:
		template <typename T> 
		T sum (T x, T y)
		{
			return(x + y);
		}
	- явная специализация:
		template <> int sum<int>(int *a, int *b)
		{
			return a + b;
		}
	

6) Ссылка - это особая переменнная ссылочного типа, которая хранит указатель на ячейку памяти, в которой хранится значение какой либо переменной. При работе со ссылками данные указатели автоматически разыминовываются. Поэтому арифметика ссылок, в отличии от арифметики указателей, меняет значение самой переменной, а не ее адреса. Также ссылка всегда привязанна к какой либо переменной и не может хранить в себе "мусор".
	Пример:
	int x = 10 // переменная x;
	int &def_x = x // переменная def_x (типа int &) - ссылка на переменную х.

7) Ключевое слово inline используется для вызова встроенных функций. Обычные и встроенные функции отличаются не написанием кода, а каким образом функция внедряется в программму. При вызове обычной функции программа сохраняет адреса комманд, следующей после вызова функции, копирует аргументы функции в стек, переходит к ячейки памяти сначалом функции, выполняет код и потом переходит к команде, адрес которой был сохранен. В случаи встроенных функций компилятор сам встраивает код функции непосредсвенно в текст программы, тем самым не требуя переходы по адресам. Однако при многократном вызове встроенных функций их код будет многократно встроен в программу, что увеличивает ее вес.
Пример использования:
	#include <iostream>
 
	using namespace std;
 
	inline void hello()
	{
	  cout<<"hello";
	}
	int main()
	{
 		 hello(); //Call it like a normal function.
 		 return 0;
	}

8)Ключевое слово auto позволяет определить тип переменной по задаваемому ей значению. 
	Пример: 
		int x = 8;
		auto y = a;// переменная у имеет тип int.
 auto также используется в определении функции для автоматического определения типа возвращаемого значения.
	Пример:
		auto sum (int x, int y)// возвращает тип int
		{
			return x + y;
		}
 Ключевое слово decltype позволяет определить тип переменной по результату выполнения выражения.
	Пример:
		int x = 3;
		int y = 5;
		decltype(x*y) c = x*y; // тип с - int.


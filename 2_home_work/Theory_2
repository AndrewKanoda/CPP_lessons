0)	Переменная в этих языках должна принадлежать ровно одному классу памяти, что указывается с помощью ключевого слова, который пишется перед типом переменной.

    auto — автоматическая (локальная). Автоматические переменные создаются при входе в функцию и уничтожаются при выходе из неё. Они видны только внутри функции или блока, в которых определены. В C++11 значение слова auto изменили.
    static — статическая переменная (локальная). a) Если static - внутри функции. Для таких переменных область видимости обычная (внутри функции), но время жизни постоянное (значение сохраняется между вызовами функции). b) static вне функции имеет другое значение.

    extern — внешняя (глобальная) переменная. Внешние переменные доступны везде, где описаны, а не только там, где определены. Использование ключевого слова extern позволяет функции использовать внешнюю переменную, даже если она определяется позже в этом или другом файле. Для таких переменных связывание с адресом происходит на этапе компоновки.
    register — регистровая переменная (локальная). Это слово является всего лишь «рекомендацией» компилятору помещать часто используемую переменную в регистры процессора для ускорения программы. 
Класс памяти можно не указывать, тогда действуют следующие умолчания:

    переменные, описанные внутри функции или блока, считаются локальными (auto)
    переменные, описанные вне всех функций, считаются внешними.
    функции считаются внешними.

Статическая переменная, описанная вне любой функции, становится внешней статической. Разница между внешней переменной и внешней статической переменной заключается в области их действия. Обычная внешняя переменная может использоваться функциями в любом файле, а внешняя статическая переменная может использоваться только функциями того же самого файла, причем после определения переменной. 

1)	В монолитной (одномодульной) программе без вложенных функций и без использования ООП может существовать только два типа области видимости: глобальная и локальная. Прочие типы существуют только при наличии в языке определённых синтаксических механизмов.

    Глобальная область видимости — идентификатор доступен во всём тексте программы (во многих языках действует ограничение — только в тексте, находящемся после объявления этого идентификатора).
    Локальная область видимости — идентификатор доступен только внутри определённой функции (процедуры).
    Видимость в пределах модуля может существовать в модульных программах, состоящих из нескольких отдельных фрагментов кода, обычно находящихся в разных файлах. Идентификатор, чьей областью видимости является модуль, доступен из любого кода в пределах данного модуля.
    Пакет или пространство имён. В глобальной области видимости искусственно выделяется поименованная подобласть. Имя «привязывается» к этой части программы и существует только внутри неё. Вне данной области имя либо вообще недоступно, либо доступно ограниченно.

2)	В ООП-языках дополнительно к вышеперечисленным могут поддерживаться специальные ограничения области видимости, действующие только для членов классов (идентификаторов, объявленных внутри класса или относящихся к нему:

    Приватная (личная, закрытая) - область видимости означает, что имя доступно только внутри методов своего класса.
    Защищённая - область видимости означает, что имя доступно только внутри своего класса и его классов-потомков.
    Общая - область видимости означает, что имя доступно в пределах области видимости, к которой относится его класс.

Пространство имён — некоторое множество, под которым подразумевается модель, абстрактное хранилище или окружение, созданное для логической группировки уникальных идентификаторов (то есть имён). Идентификатор, определённый в пространстве имён, ассоциируется с этим пространством. Один и тот же идентификатор может быть независимо определён в нескольких пространствах. Таким образом, значение, связанное с идентификатором, определённым в одном пространстве имён, может иметь (или не иметь) такое же значение, как и такой же идентификатор, определённый в другом пространстве. 

Пространство имён в C++ определяется блоком инструкций:

namespace foo {
  int bar;
}

Внутри этого блока идентификаторы могут вызываться именно так, как они были объявлены. Но вне блока требуется указание имени пространства имён перед идентификатором. Например, вне namespace foo идентификатор bar должен указываться как foo::bar. C++ содержит некоторые другие конструкции, делающие подобные требования необязательными.

3)	Почти каждому члену класса можно установить модификатор доступа (за исключением статических конструкторов и некоторых других вещей). В большинстве объектно-ориентированных языков программирования поддерживаются следующие модификаторы доступа:

    private (закрытый, внутренний член класса) — обращения к члену допускаются только из методов того класса, в котором этот член определён. Любые наследники класса уже не смогут получить доступ к этому члену. Наследование по типу private делает все члены родительского класса (в том числе public и protected) private-членами класса-наследника (С++);
    protected (защищённый, внутренний член иерархии классов) — обращения к члену допускаются из методов того класса, в котором этот член определён, а также из любых методов его классов-наследников. Наследование по типу protected делает все public-члены родительского класса protected-членами класса-наследника (С++);
    public (открытый член класса) — обращения к члену допускаются из любого кода. Наследование по типу public не меняет модификаторов родительского класса (С++);

4)	Конструктор класса - это встроенный метод класса, предназначенный для создания объекта класса с уже заданными свойствами (например, с уже инициализированными значениями полей).
	Дестру́ктор — специальный метод класса, служащий для деинициализации объекта (например освобождения памяти). 

Главные особенности этих методов:
	a) Конструктор и диструктор всегда присутвубъют в классе: их либо создаются пользователем, либо иначе генерируются компилятором.
	b) Несмотря на то, что конструктор возвращает некоторое значение, тип данного значения не указывает при написании. А вот аргументы конструктора могут как 		указываться так и нет. В первом случаи при создании объекта класса соответсвующие значения должны быть обязательно введены.
	c) Диструктор вообще не  имеет ни типа данных возвращаемого значения, ни типа аргуметов. Диструктор также может быть в классе только один, в отличии от 		конструторов.
	d) Диструктор и конструктор всегда находятся в модификасторе public.

5)	new пытается выделить достаточно динамической памяти для размещения новых данных и, в случаи успеха, выдает указатель на выделеннйю область памяти. Если new не может выделить память, то он передаст исключение типа. 
	Выделенную память можно освободить при помощи delete путем педачи указателя удаляемого объекта в данный оператор.

6)	Указатель this — это указатель на адрес объекта класса. this позволяет не создавать дополнительно ссылку на объект, а напрямую получить доступ к объекту. 
	Пример:
	class class1
	{
	public:
	int a;
	void set(int a)
	{
		this->a = a;
	}
	}
Указатель this говорит компилятору о том, что слева от знака "=" нужно взять а, как объект класс и присвоить ему значение одноименной переменной а.

7)	Объект std::cout используется для вывода чего-либо на экран. 
	Объект std::cin используется для ввода чего-либо с клавиатуры.
	Оба объекта находятся в классе iostream.
	Рассмотрим пример:

#include <iostream>

int main()
{
	int year;
	std::cin >> year; // ввод значения переменной year (например, 2019)
	std::cout << "Hello, world! Today is "<< year << std::endl;// вывод на экран строки "Hello world, today is [значение year]".
	return 0;
}









































































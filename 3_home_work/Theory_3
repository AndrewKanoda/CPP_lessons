0.  lvalue и rvalue ссылки.

lvalue - это объект, который занимает идентифицируемое место в памяти (например, имеет адрес) и может находится как слева так и справа от оператора присваивания.
rvalue - это выражение, которое представляет собой объект, который не занимает идентифицируемое место в памяти. Поэтому данное выражение всегда находится справа от знака присваивания.
Ссылку rvalue можно связать с временным объектом, однако для lvalue такое не возможно.
Пример:

int x;

int& r_x = x;  // lvalue
int&& l_x = x;  // rvalue

int x = 1;
inr& r1_x = x; //OK
int& r2_x = 2; //Error

1. Списки инициализации -  способ инициализации переменных-членов класса без использования опретора присваивания.

Пример с ипользованием оператора присваивания:

class Values
{
public:
    Values()
    {
        x = 1;
    }
private:
    int x;
};

а при помощи списков инициализации:

 Values() : x(1) // т.е. инициализирует напрямую
    {
    
    }

Необходимость в списках инициализации возникает по причине невозможности присвоения каких-либо значений private-переменным в теле конструктора. 
Также данный метод позволяет инициализировать константы, которым нельзя присвоить значение после объявления.

2. Типы конструкторов:

а) Конструктор по умолчнию 
В C++, стандарт описывает конструктор по умолчанию как конструктор, который может быть вызван без передачи аргументов (включая конструктор с параметрами, имеющими значение по умолчанию). Например:

class MyClass
{
public:
    MyClass();  // конструктор описан

private:
    int x;
};

MyClass :: MyClass() : x(100)  // конструктор определён
{
}

int main()
{
    MyClass m;  // во время работы программы создаётся объект m И вызывается конструктор по умолчанию
}
Данный конструктор генерируется автоматически если не указан какой либо другой.

б) Конструктор копировния. 

Конструктором копирования - специальный конструктор в языке программирования C++, применяемый для создания нового объекта как копии уже существующего. Такой конструктор принимает как минимум один аргумент: ссылку на копируемый объект. 

Конструктор копирования в основном необходим, когда объект имеет указатель или неразделяемую ссылку, как например, на файл, в этом случае вам обычно также потребуется деструктор и оператор присваивания.
Общая форма:
Class_name (const Class_name &ref) 
{
// тело конструктора
}
Здесь ref является ссылкой на объект в правой части инициализации.

в) Move-конструктор (конструктор премещения).
Принимает rvalue-ccылку. Позволяет ускорить программу за счёт того, что избегается лишний вызов конструктора копирования, в котором происходит копирование больших объёмов данных. Общая форма move конструктора имеет вид:

Class_name (Class_name && ref) :
{
// тело конструктора
}



3. Использование const в методах классов позволяет гарантировать, что функция не меняет значений аргумента или поля класса.
Функция type func(const Class_name& ref) не изменяет поля класса по ссылке ref.

4.Перегрузка операторов позволяет определить действия, которые будет выполнять оператор. Перегрузка подразумевает создание функции, название которой содержит слово operator и символ перегружаемого оператора. Функция оператора может быть определена как член класса, либо вне класса.

Перегрузить можно только те операторы, которые уже определены в C++. Создать новые операторы нельзя.
В случае сложения двух объетов некоторых классов, следующие записи эквивалентны
с = a + b <=> c = a .operator+(b)
также эквивалентны
d = a + b + c <=> d = a .operator+(b .operator+(c))

Ограничения перегрузки:
а) Перекруженные операции должны иметь в качестве хотябы одного из операндов пользовательский тип.
б) Новая операция должна иметь такой же синтаксис, как у исходной (н-р, нельзя перегрузить +, так чтобы он применялся с одним операндом).
в) Невозможно определить новые символы операций.
г) Существует ряд операций, которые стандарт языка запрещает перегружать.
д) В добавок, при перегрузке операций желательно руководствоваться смысловыми ограничениями. Н-р, не стоит перегружать + так, что он будет удваивать значения переменных, к которым применяется, и возвращать их разность.

5. Ключевое слово friend используется в объявлении функции, не являющейся методом класса, для предоставления доступа к полю private (Также может использоваться для предоставления другому классу доступа к полю private данного класса). Так, например, можно определить функцию

friend std::ostream& operator<<(std::ostream& os, const Class_name& c);

которая не является методом класса Class_name, но имеет доступ к его полю private.

6. Главное отличие new и delete по сравнению с malloc() и free() в том, что, кроме выделения и освобождения памяти, new и delete вызывают соответственно конструктор и деструктор типа (класса) и способны к инициализации в момент выделения памяти (new).
Также в случае неудачи new генерирует исключение bad_alloc, а malloc просто возвращает NULL.
